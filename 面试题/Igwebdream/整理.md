

[toc]

## 写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b,...,a+nb 的时间，然后写一个 myClear，停止上面的 mySetInterVal

```js
function mySetInterVal(fn, a, b) {
  this.a = a;
  this.b = b;
  this.time = 0;
  this.handle = -1;
  this.start = () => {
    this.handle = setTimeout(() => {
      fn();
      this.time++;
      this.start();
      console.log(this.a + this.time * this.b);
    }, this.a + this.time * this.b);
  };

  this.stop = () => {
    clearTimeout(this.handle);
    this.time = 0;
  };
}

var a = new mySetInterVal(
  () => {
    console.log("123");
  },
  1000,
  2000
);
a.start();
a.stop();
```

## 介绍防抖节流原理、区别以及应用，并用 JavaScript 进行实现

```js
/** 防抖:
 * 应用场景：当用户进行了某个行为(例如点击)之后。不希望每次行为都会触发方法，而是行为做出后,一段时间内没有再次重复行为，
 * 才给用户响应
 * 实现原理 : 每次触发事件时设置一个延时调用方法，并且取消之前的延时调用方法。（每次触发事件时都取消之前的延时调用方法）
 *  @params fun 传入的防抖函数(callback) delay 等待时间
 *  */
const debounce = (fun, delay = 500) => {
    let timer = null //设定一个定时器
    return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fun.apply(this, args)
        }, delay)
    }
}
/** 节流
 *  应用场景:用户进行高频事件触发(滚动)，但在限制在n秒内只会执行一次。
 *  实现原理: 每次触发时间的时候，判断当前是否存在等待执行的延时函数
 * @params fun 传入的防抖函数(callback) delay 等待时间
 * */

const throttle = (fun, delay = 1000) => {
    let flag = true;
    return function (...args) {
        if (!flag) return;
        flag = false
        setTimeout(() => {
            fun.apply(this, args)
            flag = true
        }, delay)
    }
}
```

**区别：**节流不管事件触发多频繁保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数

## 对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景

#### 1）什么是闭包

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

可以在内部函数访问到外部函数作用域。使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为null。

#### 2）闭包原理

函数执行分成两个阶段(预编译阶段和执行阶段)。

- 在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。
- 执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量

利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。

#### 3）优点

1. 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用
2. 避免变量污染全局
3. 把变量存到独立的作用域，作为私有成员存在

#### 4）缺点

1. 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏
2. 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度
3. 可能获取到意外的值(captured value)

#### 4）应用场景

**应用场景一：** 典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局。

```js
var Yideng = (function () {
    // 这样声明为模块私有变量，外界无法直接访问
    var foo = 0;

    function Yideng() {}
    Yideng.prototype.bar = function bar() {
        return foo;
    };
    return Yideng;
}());
```

**应用场景二：** 在循环中创建闭包，防止取到意外的值。

如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 3

```js
for (var i = 0; i < 3; i++) {
    document.getElementById('id' + i).onfocus = function() {
      alert(i);
    };
}
//可用闭包解决
function makeCallback(num) {
  return function() {
    alert(num);
  };
}
for (var i = 0; i < 3; i++) {
    document.getElementById('id' + i).onfocus = makeCallback(i);
}
```

## 实现lodash的_.get

用法：

```js
var object = { 'a': [{ 'b': { 'c': 3 } }] };
 
_.get(object, 'a[0].b.c');
// => 3
 
_.get(object, ['a', '0', 'b', 'c']);
// => 3
 
_.get(object, 'a.b.c', 'default');
// => 'default'
```

实现：

```js
const get = function (object, path, defaultValue = undefined) {
  const paths = Array.isArray(path) ? path : path.replace(/\[(\d+)\]/g, ".$1").split("."); 
  let result = object; 
  for (const key of paths) {
    result = Object(result)[key];
    if (result === undefined) {
      return defaultValue;
    }
  }
  return result;
};
```

## 实现add(1)(2)(3)

```js
// 函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。

// 参数固定版本
const curry = (fn) =>
(judge = (...args) =>
    args.length === fn.length
    ? fn(...args)
    : (...arg) => judge(...args, ...arg));
const add = (a, b, c) => a + b + c;
const curryAdd = curry(add);
console.log(curryAdd(1)(2)(3)); // 6
console.log(curryAdd(1, 2)(3)); // 6
console.log(curryAdd(1)(2, 3)); // 6

// 参数不固定
function add (...args) {
    //求和
    return args.reduce((a, b) => a + b)
}

function currying (fn) {
    let args = []
    return function temp (...newArgs) {
        if (newArgs.length) {
            args = [
                ...args,
                ...newArgs
            ]
            return temp
        } else {
            let val = fn.apply(this, args)
            args = [] //保证再次调用时清空
            return val
        }
    }
}

let addCurry = currying(add)
console.log(addCurry(1)(2)(3)(4, 5)())  //15
console.log(addCurry(1)(2)(3, 4, 5)())  //15
console.log(addCurry(1)(2, 3, 4, 5)())  //15
```

## 实现链式调用

链式调用的核心就在于调用完的方法将自身实例返回

```js
function Class1() {
    console.log('初始化')
}
Class1.prototype.method = function(param) {
    console.log(param)
    return this
}
let cl = new Class1()
//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。
cl.method('第一次调用').method('第二次链式调用').method('第三次链式调用')
```

## 类数组和数组的区别，dom 的类数组如何转换成数组

- 数组是一个特殊对象,与常规对象的区别：
  - 当由新元素添加到列表中时，自动更新length属性
  - 设置length属性，可以截断数组
  - 从Array.protoype中继承了方法
  - 属性为'Array'
- 类数组是一个拥有length属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。

类数组转成数组

```js
使用 Array.from()
使用 Array.prototype.slice.call()
使用 Array.prototype.forEach() 进行属性遍历并组成新的数组
```

## 介绍下 promise 的特性、优缺点，内部是如何实现的，动手实现 Promise

1）Promise基本特性

- 1、Promise有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)
- 2、Promise对象接受一个回调函数作为参数, 该回调函数接受两个参数，分别是成功时的回调resolve和失败时的回调reject；另外resolve的参数除了正常值以外， 还可能是一个Promise对象的实例；reject的参数通常是一个Error对象的实例。
- 3、then方法返回一个新的Promise实例，并接收两个参数onResolved(fulfilled状态的回调)；onRejected(rejected状态的回调，该参数可选)
- 4、catch方法返回一个新的Promise实例
- 5、finally方法不管Promise状态如何都会执行，该方法的回调函数不接受任何参数
- 6、Promise.all()方法将多个多个Promise实例，包装成一个新的Promise实例，该方法接受一个由Promise对象组成的数组作为参数(Promise.all()方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例)，注意参数中只要有一个实例触发catch方法，都会触发Promise.all()方法返回的新的实例的catch方法，如果参数中的某个实例本身调用了catch方法，将不会触发Promise.all()方法返回的新实例的catch方法
- 7、Promise.race()方法的参数与Promise.all方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给Promise.race()方法，并将返回值作为Promise.race()方法产生的Promise实例的返回值
- 8、Promise.resolve()将现有对象转为Promise对象，如果该方法的参数为一个Promise对象，Promise.resolve()将不做任何处理；如果参数thenable对象(即具有then方法)，Promise.resolve()将该对象转为Promise对象并立即执行then方法；如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为fulfilled，其参数将会作为then方法中onResolved回调函数的参数，如果Promise.resolve方法不带参数，会直接返回一个fulfilled状态的 Promise 对象。需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。
- 9、Promise.reject()同样返回一个新的Promise对象，状态为rejected，无论传入任何参数都将作为reject()的参数

2）Promise优点

- ①统一异步 API
  - Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。
- ②Promise 与事件对比
  - 和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。 Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。
- ③Promise 与回调对比
  - 解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。
- ④Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如 Array.prototype.map() ）。

3）Promise缺点

- 1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。
- 2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
- 3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
- 4、Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。

4）简单代码实现
最简单的Promise实现有7个主要属性, state(状态), value(成功返回值), reason(错误信息), resolve方法, reject方法, then方法.

```
class Promise{
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    let resolve = value => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
      }
    };
    let reject = reason => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
      }
    };
    try {
      // 立即执行函数
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }
  then(onFulfilled, onRejected) {
    if (this.state === 'fulfilled') {
      let x = onFulfilled(this.value);
    };
    if (this.state === 'rejected') {
      let x = onRejected(this.reason);
    };
  }
}
```

5）面试够用版

```
function myPromise(constructor){ let self=this;
  self.status="pending" //定义状态改变前的初始状态 
  self.value=undefined;//定义状态为resolved的时候的状态 
  self.reason=undefined;//定义状态为rejected的时候的状态 
  function resolve(value){
    //两个==="pending"，保证了了状态的改变是不不可逆的 
    if(self.status==="pending"){
      self.value=value;
      self.status="resolved"; 
    }
  }
  function reject(reason){
     //两个==="pending"，保证了了状态的改变是不不可逆的
     if(self.status==="pending"){
        self.reason=reason;
        self.status="rejected"; 
      }
  }
  //捕获构造异常 
  try{
      constructor(resolve,reject);
  }catch(e){
    reject(e);
    } 
}
myPromise.prototype.then=function(onFullfilled,onRejected){ 
  let self=this;
  switch(self.status){
    case "resolved": onFullfilled(self.value); break;
    case "rejected": onRejected(self.reason); break;
    default: 
  }
}

// 测试
var p=new myPromise(function(resolve,reject){resolve(1)}); 
p.then(function(x){console.log(x)})
//输出1
```

6）大厂专供版

```js
const PENDING = "pending"; 
const FULFILLED = "fulfilled"; 
const REJECTED = "rejected";
const resolvePromise = (promise, x, resolve, reject) => {
  if (x === promise) {
    // If promise and x refer to the same object, reject promise with a TypeError as the reason.
    reject(new TypeError('循环引用'))
  }
  // if x is an object or function,
  if (x !== null && typeof x === 'object' || typeof x === 'function') {
    // If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.
    let called
    try { // If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.
      let then = x.then // Let then be x.then
      // If then is a function, call it with x as this
      if (typeof then === 'function') {
        // If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)
        // If/when rejectPromise is called with a reason r, reject promise with r.
        then.call(x, y => {
          if (called) return
          called = true
          resolvePromise(promise, y, resolve, reject)
        }, r => {
          if (called) return
          called = true
          reject(r)
        })
      } else {
        // If then is not a function, fulfill promise with x.
        resolve(x)
      }
    } catch (e) {
      if (called) return
      called = true
      reject(e)
    }
  } else {
    // If x is not an object or function, fulfill promise with x
    resolve(x)
  }
}
function Promise(excutor) {
  let that = this; // 缓存当前promise实例例对象
  that.status = PENDING; // 初始状态
  that.value = undefined; // fulfilled状态时 返回的信息
  that.reason = undefined; // rejected状态时 拒绝的原因 
  that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数
  that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数
  function resolve(value) { // value成功态时接收的终值
    if(value instanceof Promise) {
      return value.then(resolve, reject);
    }
    // 实践中要确保 onFulfilled 和 onRejected ⽅方法异步执⾏行行，且应该在 then ⽅方法被调⽤用的那⼀一轮事件循环之后的新执⾏行行栈中执⾏行行。
    setTimeout(() => {
      // 调⽤用resolve 回调对应onFulfilled函数
      if (that.status === PENDING) {
        // 只能由pending状态 => fulfilled状态 (避免调⽤用多次resolve reject)
        that.status = FULFILLED;
        that.value = value;
        that.onFulfilledCallbacks.forEach(cb => cb(that.value));
      }
    });
  }
  function reject(reason) { // reason失败态时接收的拒因
    setTimeout(() => {
      // 调⽤用reject 回调对应onRejected函数
      if (that.status === PENDING) {
        // 只能由pending状态 => rejected状态 (避免调⽤用多次resolve reject)
        that.status = REJECTED;
        that.reason = reason;
        that.onRejectedCallbacks.forEach(cb => cb(that.reason));
      }
    });
  }

  // 捕获在excutor执⾏行行器器中抛出的异常
  // new Promise((resolve, reject) => {
  //     throw new Error('error in excutor')
  // })
  try {
    excutor(resolve, reject);
  } catch (e) {
    reject(e);
  }
}
Promise.prototype.then = function(onFulfilled, onRejected) {
  const that = this;
  let newPromise;
  // 处理理参数默认值 保证参数后续能够继续执⾏行行
  onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value;
  onRejected = typeof onRejected === "function" ? onRejected : reason => {
    throw reason;
  };
  if (that.status === FULFILLED) { // 成功态
    return newPromise = new Promise((resolve, reject) => {
      setTimeout(() => {
        try{
          let x = onFulfilled(that.value);
          resolvePromise(newPromise, x, resolve, reject); //新的promise resolve 上⼀一个onFulfilled的返回值
        } catch(e) {
          reject(e); // 捕获前⾯面onFulfilled中抛出的异常then(onFulfilled, onRejected);
        }
      });
    })
  }
  if (that.status === REJECTED) { // 失败态
    return newPromise = new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          let x = onRejected(that.reason);
          resolvePromise(newPromise, x, resolve, reject);
        } catch(e) {
          reject(e);
        }
      });
    });
  }
  if (that.status === PENDING) { // 等待态
// 当异步调⽤用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中
    return newPromise = new Promise((resolve, reject) => {
      that.onFulfilledCallbacks.push((value) => {
        try {
          let x = onFulfilled(value);
          resolvePromise(newPromise, x, resolve, reject);
        } catch(e) {
          reject(e);
        }
      });
      that.onRejectedCallbacks.push((reason) => {
        try {
          let x = onRejected(reason);
          resolvePromise(newPromise, x, resolve, reject);
        } catch(e) {
          reject(e);
        }
      });
    });
  }
};
```

## 实现 Promise.all

**1) 核心思路**

- ①接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数
- ②这个方法返回一个新的 promise 对象，
- ③遍历传入的参数，用Promise.resolve()将参数"包一层"，使其变成一个promise对象
- ④参数所有回调成功才是成功，返回值数组与参数顺序一致
- ⑤参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。

**2）实现代码**
一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了～

```javascript
function promiseAll(promises) {
  return new Promise(function(resolve, reject) {
    if(!Array.isArray(promises)){
        throw new TypeError(`argument must be a array`)
    }
    var resolvedCounter = 0;
    var promiseNum = promises.length;
    var resolvedResult = [];
    for (let i = 0; i < promiseNum; i++) {
      Promise.resolve(promises[i]).then(value=>{
        resolvedCounter++;
        resolvedResult[i] = value;
        if (resolvedCounter == promiseNum) {
            return resolve(resolvedResult)
          }
      },error=>{
        return reject(error)
      })
    }
  })
}

// test
let p1 = new Promise(function (resolve, reject) {
    setTimeout(function () {
        resolve(1)
    }, 1000)
})
let p2 = new Promise(function (resolve, reject) {
    setTimeout(function () {
        resolve(2)
    }, 2000)
})
let p3 = new Promise(function (resolve, reject) {
    setTimeout(function () {
        resolve(3)
    }, 3000)
})
promiseAll([p3, p1, p2]).then(res => {
    console.log(res) // [3, 1, 2]
})
```

## 手写发布订阅

```ts
/ 发布订阅中心, on-订阅, off取消订阅, emit发布, 内部需要一个单独事件中心caches进行存储;

interface CacheProps {
  [key: string]: Array<((data?: unknown) => void)>;
}

class Observer {

  private caches: CacheProps = {}; // 事件中心

  on (eventName: string, fn: (data?: unknown) => void){ // eventName事件名-独一无二, fn订阅后执行的自定义行为
    this.caches[eventName] = this.caches[eventName] || [];
    this.caches[eventName].push(fn);
  }

  emit (eventName: string, data?: unknown) { // 发布 => 将订阅的事件进行统一执行
    if (this.caches[eventName]) {
      this.caches[eventName].forEach((fn: (data?: unknown) => void) => fn(data));
    }
  }

  off (eventName: string, fn?: (data?: unknown) => void) { // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息
    if (this.caches[eventName]) {
      const newCaches = fn ? this.caches[eventName].filter(e => e !== fn) : [];
      this.caches[eventName] = newCaches;
    }
  }
  
}
```

## 手写数组转树

```js
var list = [
  { id: 1, name: '部门A', parentId: 0 },
  { id: 3, name: '部门C', parentId: 1 },
  { id: 4, name: '部门D', parentId: 1 },
  { id: 5, name: '部门E', parentId: 2 },
  { id: 6, name: '部门F', parentId: 3 },
  { id: 7, name: '部门G', parentId: 2 },
  { id: 8, name: '部门H', parentId: 4 }
];
function convert(list) {
  const map = list.reduce((acc, item) => {
    acc[item.id] = item
    return acc
  }, {})
  const result = []
  for (const key in map) {
    const item = map[key]
    if (item.parentId === 0) {
      result.push(item)
    } else {
      const parent = map[item.parentId]
      if (parent) {
        parent.children = parent.children || []
        parent.children.push(item)
      }
    }
  }
  return result
}
var result = convert(list)
```

## 手写用 ES6proxy 如何实现 arr[-1] 的访问

```js
const proxyArray = arr => {
    const length = arr.length;
    return new Proxy(arr, {
        get(target, key) {
            key = +key;// 将key转成数字
            while (key < 0) {
                key += length;
            }
            return target[key];
        }
    })
};
var a = proxyArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
console.log(a[1]);  // 2
console.log(a[-10]);  // 9
console.log(a[-20]);  // 8
```

## 手写实现 Array.flat()

```js
Array.prototype.myFlat = function (depth) {
        return this.reduce((accu, cur) => Array.isArray(cur) && depth > 1 ? accu.concat(cur.myFlat(depth - 1)) : accu.concat(cur), []);
    }
```

## 大数计算如何实现

```JS
const add = (num1, num2) => {
    // 获取最大长度
    const len = Math.max(num1.length, num2.length);
    // 补0
    num1 = num1.padStart(len, 0);
    num2 = num2.padStart(len, 0);
  
    let flag = 0,esult = ``,temp = 0;
    for(let i=len-1; i>=0;  i--){
      temp = flag + parseInt(num1[i]) + parseInt(num2[i])
      result = (temp%10) + result 
      flag = parseInt(temp/10)
    }
    // 判断是否进位
    return result = (flag === 1 ? '1' : '') + result;
} 

const n1 = "9007199254740990"
const n2 = "1229007199254740993443"

add(n1, n2);
 // "1229016206453995734433"
```

## 什么是深拷贝，和浅拷贝有什么区别，动手实现一个深拷贝

### 区别

- 浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的属性值，因此修改拷贝后的属性值是引用类型的，就会影响源对象
- 深拷贝就是对对象以及对象的所有子对象进行拷贝

### 实现

```js
function cloneDeep(obj) {
    if(obj === null) return null;
    if (typeof obj !== 'object') return obj;
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);
    // 获取obj的构造函数并实例化一个新的
    const cloneObj = new obj.constructor();
    Object.keys(obj).forEach(key => {
        // 递归拷贝属性
        cloneObj[key] = cloneDeep(obj[key]);
    });
    return cloneObj;
}

let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: new Date(),
    f: undefined,
    g: /\s+/g,
    fn: function () { },
    symbol: Symbol.for('Symbol')
};

let arr = [10, [100, 200], {
    x: 10,
    y: 20
}];

let clone = JSON.parse(JSON.stringify(obj));
console.log(clone);
let clone1 = cloneDeep(obj);
console.log(clone1);

// { a: 100,
//     b: [ 10, 20, 30 ],
//     c: { x: 10 },
//     d: '2020-08-01T14:46:12.461Z',
//     g: {} }
//   { a: 100,
//     b: [ 10, 20, 30 ],
//     c: { x: 10 },
//     d: 2020-08-01T14:46:12.461Z,
//     f: undefined,
//     g: /\s+/g,
//     fn: [Function: fn],
//     symbol: Symbol(Symbol) }
```

## 实现一个方法判断 html 中的标签是否闭合

正则 ^<([a-zA-Z]+)>[\s\S]*?</\1>$

## 箭头函数和普通函数的区别

1. 箭头函数没有arguments，用扩展运算符代替...
2. 箭头函数是匿名函数，不能用于构造函数，不能new
3. 箭头函数没有原型属性
4. 箭头函数不能绑定this，指的是声明的位置的this，并且不能通过call，apply，bind改变this

## ES5实现 isInteger（是否是整数）

```js
Number.isInteger = function(val){
	return typeof val === "number" && !Number.isNaN(val) && ~~val === val;
}
```

## 手写 dom 操作，翻转 li 标签，如何处理更优

```html
/*
 *有下边这样的dom结构，现在可以获取到ul，要求翻转里边li标签，如何处理更优
 */
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
```

```js
// (1)拼接html字符串,然后一次性插入ul中
const oUl = document.getElementById('root');
const aLi = Array.from(oUl.getElementsByTagName('li'));
let str = '';
for (let index = aLi.length - 1; index >= 0; index--) {
    str += `<li>${aLi[index].innerHTML}</li>`;
}
oUl.innerHTML = str;

// (2)使用文档片段
function reverseChildNodes(node = document) {
    const frag = node.ownerDocument.createDocumentFragment();
    while(node.lastChild) {
        // 每次取出最后一个子节点也会将该节点从源节点中移除,并且更新lastChild
        frag.appendChild(node.lastChild);
    }
    // 将文档碎片直接插入到node节点下
    node.appendChild(frag);
}
const oUl = document.getElementById('root');
reverseChildNodes(oUl);
```

## 是否了解 glob，glob 是如何处理文件的，业界是否还有其它解决方案？？

## 移动设备安卓与 iOS 的软键盘弹出的处理方式有什么不同？？

## iPhone 里面 Safari 上如果一个输入框 fixed 绝对定位在底部，当软键盘弹出的时候会有什么问题，如何解决？？

## 给定一个数组，按找到每个元素右侧第一个比它大的数字，没有的话返回-1 规则返回一个数组

```js
/*
 *示例：
 *给定数组：[2,6,3,8,10,9]
 *返回数组：[6,8,8,10,-1,-1]
 */
```

```js
function handler(arr = []) {
    const result = [];
    for (let i = 0, len = arr.length; i < len - 1; i++) {
        for (let j = i + 1; j < len; j++) {
            if(arr[j] > arr[i]) {
                result[i] = arr[j];
                break;
            }
            result[i] = -1;
        }
    }
    result[arr.length - 1] = -1;
    return result;
}
console.log(handler([2,6,3,8,10,9]));
```

## 说一说 promise，有几个状态，通过 catch 捕获到 reject 之后，在 catch 后面还能继续执行 then 方法嘛，如果能执行执行的是第几个回调函数

promise一共有三种状态：fulfilled（异步操作成功），rejected（异步操作失败），pending（异步操作未完成）。
通过catch捕获到reject之后，在catch后面可以继续执行then方法，catch返回的是一个新的promise实例，执行的是then方法的第一个回调函数。

## var、let、const 的区别？？

## 说一下 垃圾回收？？

## 如何实现按需加载？？

## 讲一下 import 的原理，与 require 有什么不同？？

## 请实现如下的函数-可以批量请求数据，所有的 URL 地址在 urls 参数中，同时可以通过 max 参数控制请求的并发度，当所有请求结束之后，需要执行 callback 回调函数。发请求的函数可以直接使用 fetch 即可？？

## 是否用过 restful 接口，和其他风格的有什么区别？？

## 说一下 get、post、put 的区别？？

## 说一下对面向对象的理解，面向对象有什么好处？？

## 实现输出一个十六进制的随机颜色(#af0128a)

```js
function randomColor() {
    const r = (Math.floor(Math.random() * 255)).toString(16);
    const g = (Math.floor(Math.random() * 255)).toString(16);
    const b = (Math.floor(Math.random() * 255)).toString(16);
    const a = (Math.random()).toString(16).slice(2, 4);
    console.log(a);
    return `#` + r + g + b + a;
  }
```

## 手写代码实现“kuai-shou-front-end” => “KuaiShouFrontEnd”

```js
function toLarget(string) {
  return string.replace(/\-\w/g, (str) => str.slice(1).toLocaleUpperCase() )
}

console.log(toLarget("kuai-shou-front-end"))
```

## 实现 Promise.then？？

## 平时在项目开发中都做过哪些前端性能优化？？

## 给定起止日期，返回中间的所有月份

```js
/*
* 输入两个字符串 2018-08  2018-12
* 输出他们中间的月份 [2018-9,2018-10, 2018-11]
*/
function getMonth(start, end) {
  const [startYear, startMonth] = start.split("-").map((item) => Number(item));
  const [endYear, endMonth] = end.split("-").map((item) => Number(item));

  const yearDiff = endYear - startYear;

  return Array.from({ length: endMonth - startMonth + 12 * yearDiff - 1 }).map(
    (_, index) =>
      [
        startYear + Math.floor((index + startMonth) / 12),
        (startMonth + index) % 12 + 1,
      ].join("-")
  );
}

console.log(getMonth('2018-2', '2018-12'))
```

## 按要求实现代码

```js
// 给两个数组 [A1,A2,B1,B2,C1,C2,D1,D2] [A,B,C,D]
// 输出 [A1,A2,A,B1,B2,B,C1,C2,C,D1,D2,D]
function insertArr(arrA = [], arrB = []){
    if(!arrA || !arrA.length) return arrB;
    if(!arrB || !arrB.length) return arrA;
    const arr = JSON.parse(JSON.stringify(arrA));
    arr.sort((a, b) => a.localeCompare(b));
    const result = [];
    for (const str of arrB) {
        const temp = arr.filter(item => item.includes(str));
        result.push(...temp, str);
    }
    return result;
}
console.log(insertArr(['A1','A2','B1','B2','C1','C2','D1','D2'], ['A','B','C','D']));
```

## 用尽量短的代码实现一个 arrary 的链式操作，将数组中的大于 10 的值进行一个累加

```js
function add(arr) {
  return arr.reduce((sum, item) => item > 10 ? sum + item : sum ,0)
}
```

## 简单封装一个异步 fecth，使用 async await 的方式来使用

```js
~(async () => {
    class HttpRequestUtil {
        async get(url) {
            const res = await fetch(url);
            const data = await res.json();
            return data;
        }
        async post(url, data) {
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async put(url, data) {
            const res = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async delete(url, data) {
            const res = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
    }
    const httpRequestUtil = new HttpRequestUtil();
    const res = await httpRequestUtil.get('http://golderbrother.cn/');
    console.log(res);
})();
```

## 请写一个函数，输出出多级嵌套结构的 Object 的所有 key 值

```js
var obj = {
  a: '12',
  b: '23',
  first: {
    c: '34',
    d: '45',
    second: { 3: '56', f: '67', three: { g: '78', h: '89', i: '90' }}
  }
}
function getObjAllKeys(obj, res = []) {
  for (const key in obj) {
    res.push(key)
    if (typeof obj[key] === 'object') {
      getObjAllKeys(obj[key], res)
    }
  }
  return res
}
getObjAllKeys(obj)
```

## 动手实现一个 repeat 方法

```js
function repeat(func, times, wait) {
    function sleep(fn, wait, args) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    const res = typeof fn === 'function' && fn.apply(this, args);
                    resolve(res);
                } catch (error) {
                    reject(error);
                }
            }, wait);
        });
    }
    // TODO
    return async function (...args) {
        const promises = new Array(times).fill(sleep);
        for (const p of promises) {
            await p(func, wait, args);
        }
    }

}
const repeatFunc = repeat(console.log, 4, 3000);
repeatFunc ("hellworld");

```

## setTimeout 有什么缺点，和 requestAnimationFrame 有什么区别

`requestAnimationFrame` 的执行时机是浏览器去决定的，比如当前设备刷新率是60Hz，那它的执行就会是16.67ms。也可以说它的回调函数的执行是与屏幕的刷新有关，每刷完一次，就要执行一次，不会卡顿和掉帧。由于它定义的回调是在**下次重绘**之前，所以必须在回调里再调用一次，才能实现连续的动画。而且 `requestAnimationFrame` 在页面隐藏掉或最小化的时候，是不会执行的，这样就节省了一些不必要的系统资源。所以使用 `requestAnimationFrame` 比 `setTimeout` 好处要多。

## versions 是一个项目的版本号列表，因多人维护，不规则，动手实现一个版本号处理函数

```js
var versions = ["1.45.0", "1.5", "6", "3.3.3.3.3.3.3"];
// 要求从小到大排序，注意'1.45'比'1.5'大
function sortVersion(versions) {
  // TODO
  if (!versions || !versions.length) return [];
	const result = versions.sort((a, b) => {
		const arrA = a.split('.'), arrB = b.split('.');
		const length = Math.max(a.length, b.length);
		for (let i = 0; i < length; i++) {
			const x = Number(arrA[i] || 0);
			const y = Number(arrB[i] || 0);
			if (x - y !== 0) return x - y;
		}
	});
	return result;
}
// => ['1.5','1.45.0','3.3.3.3.3.3','6']
```

## 实现一个多并发的请求??

```js
let urls = ['http://dcdapp.com', …];
/*
	*实现一个方法，比如每次并发的执行三个请求，如果超时（timeout）就输入null，直到全部请求完
	*batchGet(urls, batchnum=3, timeout=3000);
	*urls是一个请求的数组，每一项是一个url
	*最后按照输入的顺序返回结果数组[]
*/
```

## 实现以下函数??

```js
const a = sum(); // => a === 0
const b = sum(); // => b === 2
const c = sum(4)(5); // c === 9
const k = sum(n1)...(nk) // k === n1 + n2 + ... + nk
```

## 说一下 base64 的编码方式

> https://zh.wikipedia.org/wiki/Base64

## 改变 this 指向的方式都有哪些？

new call apply bind

## 说一下`module.exports`和`exports`的区别，`export`和`export default`的区别

`module`和`exports`是`Node.js`给每个js文件内置的两个对象。可以通过`console.log(module)`和`console.log(exports)`打印出来。如果你在`main.js`中写入下面两行，然后运行`$ node main.js`:

```cpp
console.log(exports);//输出：{}
console.log(module);//输出：Module {..., exports: {}, ...} （注：...代表省略了其他一些属性）
```

从打印我们可以看出，`module.exports`和`exports`一开始都是一个空对象`{}`，**实际上，这两个对象指向同一块内存**。这也就是说`module.exports`和`exports`是等价的（有个前提：不去改变它们指向的内存地址）。

例如：`exports.age = 18`和`module.export.age = 18`，这两种写法是一致的（都相当于给最初的空对象`{}`添加了一个属性，通过`require`得到的就是`{age: 18}`）。

#### 但是

**`require`引入的对象本质上是`module.exports`**。这就产生了一个问题，当 `module.exports`和`exports`指向的不是同一块内存时，`exports`的内容就会失效。
 例如：

```java
module.exports = {name: '萤火虫叔叔'}；
exports = {name: '萤火虫老阿姨'}
```

此时`module.exports`指向了一块新的内存（该内存的内容为`{name: '萤火虫叔叔'}`），`exports`指向了另一块新的内存（该内存的内容为`{name: '萤火虫老阿姨'}`）。`require`得到的是`{name: '萤火虫叔叔'}`。

附上代码（在main.js中引入people.js）：

```java
//people.js
module.exports = {name: '萤火虫叔叔'}；
exports = {name: '萤火虫老阿姨'};
```

```jsx
//main.js
let people = require('./people');
console.log(people);//输出：{name: '萤火虫叔叔'}
```

在es5中，用`module.exports`和`exports`导出模块，用`require`引入模块。
 es6新增`export`和`export default`导出模块，`import`导入模块。

##### 一、在es6中的两种基本用法

新建两个文件：`a.js`, `b.js`。`a.js`用于导出模块，`b.js`用于导入模块。两个文件放在同一目录下。

- 第一种用法
   `export default`导出：

```dart
//a.js
const Programmer = {name: 'UncleFirefly',age:25}
export default Programmer
```

`export default`导出对应的导入：

```jsx
//b.js
import Programmer from './a.js'
```

- 第二种用法
   `export`导出：

```dart
//a.js
const uncle = {name: 'UncleFirefly',age:25}
const aunt = {name: 'AuntFirefly',age:25}
export {uncle, aunt}
```

`export default`导出对应的导入：

```jsx
//b.js
import {uncle, aunt} from './a.js'
```

##### 二、区别

可以在`a.js`中打印出module，通过打印的内容找到4种导出模块的区别。

- `exports`和`module.exports`的区别
   查看`exports`和`module.exports`的区别请移步至我的另一篇文章：[点我移步](https://www.jianshu.com/p/beafd9ac9656)。
- `export`和`export default`的区别



```jsx
//a.js
const Programmer = {name: 'UncleFirefly',age:25}
export default Programmer
console.log(module)
/*
//打印结果
{exports: {default:{age:25,name:'UncleFirefly'}, hot:{...}}
*/
```



```dart
//a.js
const uncle = {name: 'UncleFirefly',age:25}
const aunt = {name: 'AuntFirefly',age:25}
export {uncle, aunt}
/*
//打印结果
{exports: {aunt:{age:25,name:'AuntFirefly'},uncle:{age:25,name:'UncleFirefly'}, hot:{...}}
*/
```

从打印可以看出:

- 导出时
  - `export`相当于把对象添加到`module`的`exports`中。
  - `export default`相当于把对象添加到`module`的`exports`中，并且对象的key叫`default`。
- 导入时：
  - 不带`{}`的导入
     本质上就是导入`exports`中的`default`属性（注：如果`default`属性不存在，则导入`exports`对象）。
  - 带`{}`的导入
     本质上按照属性key值导入`exports`中对应的属性值。

##### 三、小tips

一般来说，`module.exports`、`exports`与`require`对应。也就是用`module.exports`、`exports`导出的模块，则用`require`导入。（不是绝对，如果代码支持es6，也可以用import引入）。

## number 为什么会出现精度损失，怎样避免

[链接](../JS/JS为什么会出现精度问题.md)

## 实现一个函数将中文数字转成数字？？

## 要求⽤不同⽅式对 A 进⾏改造实现 A.name 发⽣变化时⽴即执⾏ A.getName

```js
// 方法一
let _name = '123';
const A = {
    get name(){
        return _name
    },
    set name(name){
        _name = name;
        this.getName();
    },
    getName() {
        console.log(this.name);
    }
}
A.name = 'james';
A.name = 'robin';

// 方法二
function defineReactive(obj, key, val) {
    if (typeof obj !== 'object' || obj === null) return;
    Object.defineProperty(obj, key, {
        get() {
            return val;
        },
        set(newVal) {
            if (newVal === val) return;
            val = newVal;
            typeof obj.getName === 'function' && obj.getName();
        }
    });
}

const A = { name: 'sfd', getName: function () { console.log(this.name) } };
defineReactive(A, 'name');
A.name = 'james';
A.name = 'robin';
// james
// robin

// 方法三
const A = { name: 'sfd', getName: function () { console.log(this.name) } };
function defineReactive(obj, customKey, val) {
    const handler = {
        get(target, key, receiver) {
            const res = Reflect.get(target, key, receiver);
            return res;
        },
        set(target, key, value, receiver) {
            const res = Reflect.set(target, key, value, receiver);
            if (key === customKey && typeof obj.getName === 'function') obj.getName();
            return res;
        }
    };
    const observer = new Proxy(obj, handler);
    return observer;
}
const _A = defineReactive(A, 'name');
_A.name = 'james';
_A.name = 'robin';
// james
// robin
```

## 修改以下代码，使得最后⼀⾏代码能够输出数字 0-9（最好能给多种答案）

```js
var arrys = [];
for (var i = 0; i < 10; i++) {
  arrys.push(function () {
    return i;
  });
}
arrys.forEach(function (fn) {
  console.log(fn());
}); //本⾏不能修改
```

```js
var arrys = [];
for (var i = 0; i < 10; i++) {
  (function(_i){
    arrys.push(function () {
      return _i;
    });
  })(i);
}
arrys.forEach(function (fn) {
  console.log(fn());
}); //本⾏不能修改

// 方法二：let块级作用域
var arrys = [];
for (let i = 0; i < 10; i++) {
  arrys.push(function () {
    return i;
  });
}
arrys.forEach(function (fn) {
  console.log(fn());
}); //本⾏不能修改

// 方法三
var arrys = [];
for (var i = 0; i < 10; i++) {
  arrys.push((function (_i) {
    return () => _i
  }(i)));
}
arrys.forEach(function (fn) {
  console.log(fn());
}); //本⾏不能修改
```

## 请给出识别 Email 的正则表达式

```js
function verifyEmail(email){
    // 1204788939@qq.com
    const reg = /\w+((-\w+)|(\.\w+))*@[a-zA-Z0-9]+((\.|-)[a-zA-Z0-9]+)*\.[a-zA-Z0-9]+$/;
    return reg.test(email);
}
```

## Promise 链式调用如何实现??

## 说一下对`BigInt`的理解，在什么场景下会使用??

## 说一下对于堆栈的理解??

##  `[] == ![]`为什么

结果：true

1. ![] 转为 bool值，为false
   2, false转为 number 为0
   3, []转为number为0

所以 0==0 返回true

引申一下， {} ==!{} 返回false
转换顺序跟逻辑也是一致的，不过{}转number时为NaN
所以NaN == 0 返回false

## 如何把真实 dom 转变为虚拟 dom，代码实现一下

```js
// 首先我们先定义好，一个虚拟dom类，用来表示dom
// 这里定义的比较简单
// 标签名，属性，子级
function Element(tag, props, children) {
  this.tag = tag;
  this.props = props;
  this.children = children;
}

// 生成虚拟dom
// 传入一个节点，就会生成对应的虚拟dom
function genVirtualDom(el) {
  const tag = el.nodeName;
  const attributes = el.attributes;
  const childNodes = el.childNodes;
  
  // 遍历属性，生成props
  const props = {};
  for (const node of attributes) {
  	props[node.nodeName] = node.nodeValue
  }
  
  // 遍历子级，生成children
  const children = [];
  childNodes.forEach(child => {
      if(child.nodeType === 1) { // 元素节点
          child = genVirtualDom(child)
        } else { // 文本节点
    	    child = child.nodeValue;
        }
    children.push(child)
  })
  
  return new Element(tag, props, children);
}
```

## 说一下错误监控的实现，错误监控的正确使用方式，日志如何分等级??

## 说一下什么是死锁??

## 实现以下代码

```js
function add() {
  // your code
  return Array.from(arguments).flat(Infinity).reduce((sum, item) => sum + item, 0)
}
function one() {
  // your code
    return Array.from(arguments).concat([1])
}
function two() {
  // your code
    return Array.from(arguments).concat([2])
}
console.log(add(one(two()))); //3
console.log(add(two(one()))); //3
```

## 请实现一个 cacheRequest 方法，保证发出多次同一个 ajax 请求时都能拿到数据，而实际上只发出一次请求??

## 说一下对原型链的理解，画一个经典的原型链图示

![原型链](/Users/zcool/Desktop/面试/public/images/原型链.png)

## 说一下 ajax/axios/fetch 的区别??

## 描述 DOM 事件捕获的具体流程??

## 请实现`$on,$emit`

```js
class Event {
    constructor(){
        this.eventHub = {};
    }
    on(eventName, fn){
        (this.eventHub[eventName] || (this.eventHub[eventName] = [])).push(fn);
    }
    off(eventName, fn){
        if(fn) {
            if(Array.isArray(this.eventHub[eventName])) this.eventHub[eventName] = this.eventHub[eventName].filter(func => func !== fn);
        }else {
            this.eventHub[eventName] = [];
        }
    }
    emit(eventName, ...args) {
        if(Array.isArray(this.eventHub[eventName])) {
            this.eventHub[eventName].forEach(fn => {
                typeof fn === 'function' && fn.apply(this, args);
            });
        }
    }
    once(eventName, fn) {
        const onceWrap = (...args) => {
            fn.apply(this, args);
            this.off(event, fn);
        }
        this.on(eventName, onceWrap);
    }
}

function test(a) {
    console.log(a)
}
var event = new Event()
event.once('test', test)
event.emit('test', 1) // 1
```

## 实现 bind 方法，不能使用 call、apply、bind??

## 请写出原生 js 如何设置元素高度??













